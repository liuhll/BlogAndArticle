# awk命令

- [awk命令参考](http://man.linuxde.net/awk)

## 简介
- `awk`是一种**编程语言**，用于在`linux/unix`下对*文本*和*数据*进行处理。
    - **数据**可以来*自标准输入(`stdin`)*、
    - 一个或多个*文件*
    - 或*其它命令的输出*
- 支持**用户自定义函数**和**动态正则表达式**等先进功能，是`linux/unix`下的一个强大编程工具。
- 它在**命令行**中使用，但更多是作为*脚本来使用*。
- `awk`有很多内建的功能
   - 比如`数组`、`函数`等
   - 这是它*和C语言的相同之处*
- **灵活性**是`awk`最大的优势 

## awk命令格式和选项 
 
### 语法形式
1. 命令行方式
```bash
awk [options] 'script' var=value file(s) 
```

2.  将所有的`awk`命令插入一个单独文件，然后调用
```bash
awk [options] -f scriptfile var=value file(s)
```

### 常用命令选项 
- `-F fs` `fs`指定输入分隔符，`fs`可以是`字符串`或`正则表达式`
   - **如**`-F:`
- `-v var=value` 赋值一个`用户定义变量`，将`外部变量`传递给`awk` 
- `-f scripfile` 从脚本文件中读取`awk`命令 
-  `-m[fr] val` 对`val`值设置内在限制，
    - `-mf`选项限制分配给`val`的**最大块数目**；
    - `-mr`选项限制**记录的最大数目**。
     > **Notes**  
     >  这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。

## awk模式和操作 

`awk脚本`是由`模式`和`操作`组成的。 

### 模式
- `/正则表达式/`：使用**通配符**的扩展集。 
- `关系表达式`：使用`运算符`进行操作，可以是*字符串*或*数字*的比较测试。 
- `模式匹配表达式`：用`运算符` 
    - `~`（*匹配*）  
    - `~!`（*不匹配*）。 
- `BEGIN`语句块、`pattern`语句块、`END`语句块：[参见awk的工作原理](##awk的工作原理) 

### 操作
- `操作`由一个或多个*命令*、*函数*、*表达式*组成，之间由`换行符`或`分号`隔开，并位于`大括号`内，
- 主要部分是：
  - `变量`或`数组`赋值
  - 输出命令
  - 内置函数
  - **控制流**语句

## awk脚本基本结构 

```bash
awk 'BEGIN{ print "start" } pattern{ commands } END{ print "end" }' file 
```
一个`awk脚本`通常由：
1. `BEGIN语句块`、
2.  能够使用模式匹配的`通用语句块`、
3. `END语句块`3部分组成，

> **Notes**
> - 这三个部分是可选的，任意一个部分都可以**不出现**在脚本中
> - `脚本`通常是被`单引号`或`双引号`中

```bash
awk "BEGIN{ i=0 } { i++ } END{ print i }" filename  #或者
awk 'BEGIN{ i=0 } { i++ } END{ print i }' filename 

```

## awk的工作原理

```bash
awk 'BEGIN{ commands } pattern{ commands } END{ commands }' 
```

1. **第一步**：执行`BEGIN{ commands }`语句块中的语句； 
2. **第二步**：从**文件或标准输入**(`stdin`)**读取一行**，然后执行`pattern{ commands }语句块`，它**逐行扫描文件**，
从第一行到最后一行重复这个过程，直到文件全部被读取完毕。
3. **第三步**：当读至输入流末尾时，执行`END{ commands }`语句块。

> **Notes**
> - `BEGIN语句块`在`awk`开始从`输入流`中读取行**之前**被执行，这是一个*可选的语句块*，
>     - 比如**变量初始化**、
>     - **打印输出表格的表头**等语句
> - `END语句块在`  `awk`从`输入流`中读取完所有的行**之后**即被执行
>     - 比如**打印所有行的分析结果**这类信息汇总都是在`END语句块`中完成
>     - 它也是一个**可选语句块**
> - `pattern语句块`中的**通用命令是最重要的部分**
>    - 它也是**可选**的
>    - 如果**没有**提供`pattern语句块`，则**默认执行**`{ print }`即打印每一个读取到的行，`awk`读取的每一行都会执行该语句块。

- **示例**
    ```bash
    $ echo -e "A line 1\nA line 2" | awk.exe 'BEGIN{ print "Start" } { print } END{ print "End" }'
    Start
    A line 1
    A line 2
    End

    ```
### `pattern`语句块
- 当使用**不带**参数的`print`时，它就打印当前行
- 当`print`的参数是以`逗号`进行分隔时，打印时则以`空格`作为`定界符`。
- 在`awk`的`print语句块`中`双引号`(`"`)是被当作`拼接符`使用 【**注意**】

   - **示例**
   ```bash
   $ echo | awk '{ var1="v1"; var2="v2"; var3="v3"; print var1"="var2"="var3; }' 
   v1=v2=v3 

   ```

- `{ }`类似一个**循环体**，
    - 会对文件中的**每一行进行迭代**
- 通常变量**初始化语句**（如：`i=0`）以及**打印文件头部的语句**放入`BEGIN语句块`中，
- 将打印的**结果**等语句放在`END语句块`中。 

##awk内置变量（预定义变量） 

> - **说明：**
> - `[A]` `[N]` `[P]` `[G]`表示第一个支持变量的工具，`[A]=awk`、`[N]=nawk`、`[P]=POSIXawk`、`[G]=gawk`

| 变量名 | 说明   |
|:-------|:------|
| $n | 当前记录的第`n`个字段，比如<br/>*n为1表示第一个字段*，</br>*n为2表示第二个字段。* |
| $0 | 这个变量包含执行过程中当前行的文本内容。 | 
| [N] ARGC | 命令行**参数的数目**。 | 
| [G] ARGIND | 命令行中当前文件的位置（从0开始算）。 |
| [N] ARGV | 包含命令行参数的数组。 |
|  [G] CONVFMT | 数字转换格式（默认值为%.6g）。|
| [P] ENVIRON |环境变量关联数组。 |
| [N] ERRNO | 最后一个系统错误的描述。 |
|  [G] FIELDWIDTHS | 字段宽度列表（用空格键分隔）。 |
| [A] FILENAME | 当前输入文件的名。 |
| [P] FNR | 同NR，但相对于当前文件。 |
|  [A] FS | 字段分隔符（默认是任何空格）。 |
| [G] IGNORECASE  |如果为真，则进行忽略大小写的匹配。 |
|  [A] `NF`  * | 表示**字段数**，在执行过程中对应于当前的字段数。|
| [A] `NR`  * | 表示**记录数**，在执行过程中对应于当前的行号。 |
| [A] OFMT | 数字的输出格式（默认值是%.6g）。 |
| [A] OFS | 输出字段分隔符（默认值是一个空格）。 |
|  [A] ORS | 输出记录分隔符（默认值是一个换行符）。 |
|  [A] RS | 记录分隔符（默认是一个换行符）。 |
|  [N] RSTART | 由`match函数`所匹配的字符串的第一个位置。 |
|  [N] RLENGTH | 由`match函数`所匹配的字符串的长度。|
|  [N] SUBSEP  | 数组下标分隔符（默认值是34）。 |


- **示例**
   ```bash
   $ echo -e "line1 f2 f3\nline2 f4 f5\nline3 f6 f7" | awk '{print "Line No:"NR", No of fields:"NF, "$0="$0, "$1="$1, "$2="$2, "$3="$3}' 
    Line No:1, No of fields:3 $0=line1 f2 f3 $1=line1 $2=f2 $3=f3 
    Line No:2, No of fields:3 $0=line2 f4 f5 $1=line2 $2=f4 $3=f5
    Line No:3, No of fields:3 $0=line3 f6 f7 $1=line3 $2=f6 $3=f7
   ```

> **特别注意**
> - 使用`print $NF`可以打印出一行中的**最后一个字段**，使用`$(NF-1)`则是打印**倒数第二个字段**，其他以此类推
> - 统计文件中的**行数**
>     - `awk 'END{ print NR }' filename`
>     - 以上命令只使用了`END语句块`，在读入每一行的时，`awk`会将`NR`更新为对应的行号，当到达最后一行`NR`的值就是最后一行的**行号**，所以`END语句块`中的`NR`就是文件的`行数`
 
## 将外部变量值传递给awk 

1. 借助`-v`选项，可以将*外部值*（并非来自`stdin`）传递给`awk`：

```bash
$ VAR=10000 
$ echo | awk -v VARIABLE=$VAR '{ print VARIABLE }' 

``` 

2. 另一种传递外部变量方法：`变量`之间用`空格`分隔作为`awk`的**命令行参数**跟随在BEGIN、{}和END语句块之后。 


```bash
$ var1="aaa"
$ var2="bbb" 
$ echo | awk '{ print v1,v2 }' v1=$var1 v2=$var2 
```
> 当输入来自于文件时使用： 

```bash
awk '{ print v1,v2 }' v1=$var1 v2=$var2 filename 
```

## `awk`运算与判断 

- `awk`支持多种运算，这些运算与`C语言`提供的基本相同。
- `awk`还提供了一系列**内置的运算函数**（如`log`、`sqr`、`cos`、`sin`等）
- 一些用于对`字符串`进行**操作**（运算）的函数（如`length`、`substr`等等）。
    - 这些函数的引用大大的提高了`awk`的运算功能。
- 作为对条件转移指令的一部分，**关系判断**是每种程序设计语言都具备的功能，`awk`也不例外，`awk`中允许进行**多种测试**，
- 作为样式匹配，还提供了**模式匹配表达式** `~`（匹配）和 `~!`（不匹配）。
- 作为对测试的一种扩充，`awk`也支持用**逻辑运算符**。 

### 算术运算符
| 运算符 |	描述 |
|:------|:-----|
|  + -  |	加，减 |
|  * / & |	乘，除与求余 |
|  + - ! |	一元加，减和逻辑非 |
|  ^ *** |	求幂 |
|  ++ -- |	增加或减少，作为前缀或后缀 |

### 赋值运算符
| 运算符 |	描述 |
|:------|:-----|
|  = += -= *= /= %= ^= **= |	赋值语句 |

### 正则运算符

| 运算符 |	描述 |
|:------|:-----|
|  `~` / `~!` |	匹配正则表达式和不匹配正则表达式 |

### 关系运算符

| 运算符 |	描述 |
|:------|:-----|
|  < <= > >= != == |	关系运算符 |

>  **Notes**  
> - `>` `<` 可以作为**字符串**比较，也可以用作**数值**比较，关键看操作数如果是字符串就会转换为字符串比较。
> - **两个都为数字**才转为数值比较。
> - 字符串比较：按照`ASCII码`顺序比较。

### 其它运算符

| 运算符 |	描述 |
|:------|:-----|
|  $ |	字段引用 |
|  空格 |	字符串连接符 |
|  ?: |	C条件表达式 |
|  in |	数组中是否存在某键值 |


## awk高级输入输出 

### 读取下一条记录
- `next`语句
   - 在循环逐行匹配，如果遇到`next`，就会跳过当前行，直接忽略下面语句。
   - 而进行下一行匹配。 `next`语句一般用于**多行合并**
   ```bash
   $ cat text.txt
     a
     b
     c 
     d 
     e 
   $ awk 'NR%2==1{next}{print NR,$0;}' text.txt # 行号除以2余1，就跳过当前行。下面的print NR,$0也不会执行
     2 b
     4 d

   ```


## 设置字段定界符 
- **默认的字段定界符是空格**
- 可以使用`-F` **定界符"** 明确指定一个定界符

```bash
$ awk -F: '{ print $NF }' /etc/passwd
# 或
$ awk 'BEGIN{ FS=":" } { print $NF }' /etc/passwd

```

## 流程控制语句 
- 在`linux` `awk`的`while`、`do-while`和`for`语句中允许使用`break`,`continue`语句来控制流程走向，
- 也允许使用`exit`这样的语句来退出。
- `break`中断当前正在执行的循环并跳到循环外执行下一条语句。
- `if` 是流程选择用法。
- `awk`中，**流程控制语句**，**语法结构**，与`c`语言类型。
- 有了这些语句，其实很多`shell`程序都可以交给`awk`，而且性能是非常快的。


### 条件判断语句

```bash
if(表达式)
   语句1
else
   语句2
```

> 为了方便判断和阅读，最好将多个语句用{}括起来

```bash
if(表达式)
   {语句1} 
else if(表达式)
   {语句2} 
else 
   {语句3}

```

- 示例

```bash
awk 'BEGIN{
    test=100;
    if(test>90)
      { print "very good"; } 
    else if(test>60)
      { print "good"; }
    else{ print "no pass"; }
     }'
# 输出
#very good
```

> 每条命令语句后面可以用;分号结尾。

### 循环语句

#### while语句
```bash
while(表达式) 
{语句}
```

#### for循环
1. 格式1

```bash
for(变量 in 数组) 
  {语句}
```
2. 格式2

```bash
for(变量;条件;表达式) 
   {语句}
```

#### do循环

```bash
do 
  {语句} while(条件)
```

### 其他语句
- `break`
  - 当 `break` 语句用于 `while` 或 `for` 语句时，导致退出程序循环。
- `continue`
   - 当 `continue` 语句用于 `while` 或 `for` 语句时，使程序循环移动到下一个迭代。
- `next`
   - 能能够导致读入下一个输入行，并返回到脚本的顶部。
   - 这可以避免对当前输入行执行其他的操作过程。
- `exit` 语句
   - 使主输入循环退出并将控制转移到`END`,如果`END`存在的话。
   - 如果**没有**定义`END`规则，或在`END`中应用`exit`语句，则终止脚本的执行。

## 数组的定义
- **数组**是`awk`的灵魂，处理文本中最不能少的就是它的数组处理。
- **数组索引**（`下标`）可以是`数字`和`字符串`
- 在`awk`中数组叫做`关联数组`(`associative arrays`)。
- `awk` 中的数组不必提前声明，也不必声明大小。
- 数组元素用`0`或**空字符串**来初始化，这根据上下文而定。

### 数组的定义
1. 数字做数组索引（下标）： 

```bash
Array[1]="sun" Array[2]="kai"
```

2. 字符串做数组索引（下标）： 

```bash
Array["first"]="www" 
Array["last"]="name" 
Array["birth"]="1987"
```

## 格式化字符串输出（sprintf使用） 
- **格式化字符串**包括两部分内容：
   1. 一部分是正常字符，这些字符将按原样输出;
   2. 另一部分是格式化规定字符，以`%`开始，后跟一个或几个规定字符,用来确定输出内容格式。

| 格式 |	描述 |
|:-----|:-----|
| %d |	十进制有符号整数 |
| %u |	十进制无符号整数 |
| %f |	浮点数 |
|  %s |	字符串 |
|  %c |	单个字符 |
|  %p |	指针的值 |
| %e |	指数形式的浮点数 |
|  %x	%X | 无符号以十六进制表示的整数 |
|  %o |	无符号以八进制表示的整数 |
|  %g |	自动选择合适的表示法 |

```bash
$ awk 'BEGIN{n1=124.113;n2=-1.224;n3=1.2345; printf("%.2f,%.2u,%.2g,%X,%on",n1,n2,n3,n1,n1);}' 
124.11,18446744073709551615,1.2,7C,174

```

