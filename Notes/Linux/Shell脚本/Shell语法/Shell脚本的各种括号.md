# shell中各种括号的作用()、(())、[]、[[]]、{}

## 小括号，圆括号（）

### 单小括号 `()`

1. 命令组
   - `括号`中的命令将会新开一个`子shell`顺序执行
       - 所以`括号`中的`变量`**不能**够被脚本余下的部分使用
   - `括号`中多个命令之间用`分号`隔开，*最后一个命令可以没有分号*
   - 各命令和括号之间**不必有空格**

2. 命令替换
   - 等同于`cmd`
   - `shell`扫描一遍命令行，发现了`$(cmd)`结构，便将`$(cmd)`中的`cmd`执行一次，得到其标准输出，再将此输出放到原来命令
   - `有些shell`不支持，如`tcsh`

3. 用于初始化数组
   
    ```bash
    array=(a b c d)
    ```

### 双小括号 `(( ))`
1. 整数扩展
    - `整数型`的计算，**不支持**`浮点型`
    - `((exp))`结构扩展并计算一个**算术表达式**的值
       - 如果表达式的结果为`0`，那么返回的退出状态码为`1`，或者 是`假`，
       - 而一个非零值的表达式所返回的退出状态码将为`0`，或者是`true`
       - **逻辑判断**，表达式`exp`为`真`则为`1`,`假`则为`0`

2. 只要`括号`中的**运算符**、**表达式**符合`C语言`运算规则，都可用在`$((exp))`中，甚至是`三目运算符`   
   - 作**不同进位**(如`二进制`、`八进制`、`十六进制`)运算时，输出结果全都自动转化成了`十进制`
      - `echo $((16#5f))` 结果为`95`
3. 单纯用 `(( ))` 也可重定义变量值
    - `a=5; ((a++))` 可将 `$a` 重定义为`6`

4. 常用于算术运算比较，`双括号`中的变量可以**不使用**`$`符号前缀
   - 括号内支持**多个表达式**用`逗号`分开
      - 只要`括号`中的表达式符合`C语言`运算规则
      - 可以直接使用`for((i=0;i<5;i++))`
   - 可以直接使用`if (($i<5))`
      - 如果不使用双括号, 则为`if [ $i -lt 5 ]`   
      

> **Notes**  
> - **不使用双括号**, 则为下列
```bash
for i in `seq 0 4`
```
```bash
for i in {0..4}
```


## 中括号，方括号`[]`

### 单中括号 `[]`
1. `bash` 的内部命令，`[`和`test`是**等同**的
   - 如果我们**不用绝对路径指明**，通常我们用的都是`bash`自带的命令
   - `if/test`结构中的`左中括号`是调用`test`的命令标识，`右中括号`是**关闭条件判断**的
   - 该把它的参数作为**比较表达式**或者作为**文件测试**，并且根据*比较的结果*来**返回一个`退出状态码`**
   - `if/test`结构中并不是必须`右中括号`，但是新版的`Bash`中要求必须这样

2. `Test`和`[]`中可用的比较运算符只有`==`和`!=`，两者都是**用于字符串比较的**
   - **不可用于整数比较**，整数比较只能使用`-eq`，`-gt`这种形式   
   - 无论是*字符串比较*还是*整数比较*都**不支持**`大于号` `小于号`
      - 对于`字符串`比较可以使用**转义形式**，如果比较`"ab"`和`"bc"`：`[ ab \< bc ]`，结果为真，也就是返回状态为`0`
   - `[ ]`中的逻辑`与` `和`逻辑或使用`-a` 和`-o` 表示

3. 字符范围
   - 用作`正则表达式`的一部分，描述一个**匹配的字符范围**
      - 作为`test`用途的`中括号`内**不能**使用正则

4. 在一个`array` 结构的上下文中，`中括号`用来引用数组中**每个元素的编号**

### 双中括号`[[ ]]`
1. `[[`是 `bash` 程序语言的**关键字**
   - **不是**一个命令，`[[ ]]` 结构比`[ ]`结构更加通用
   - 在`[[`和`]]`之间所有的字符都*不会发生文件名扩展或者单词分割*，但是**会发生参数扩展和命令替换**
2. 支持**字符串的模式匹配**，使用`=~`操作符时甚至支持`shell`的`正则表达式`
   - 字符串比较时可以把**右边**的作为一个模式，而**不仅仅是一个字符串**
      - **例子**： `[[ hello == hell? ]]`，结果为`真`
   - `[[ ]]` 中**匹配字符串**或**通配符**，**不需要引号**   

3. 使用`[[ ... ]]`条件判断结构，而**不是**`[ ... ]`，能够防止脚本中的许多逻辑错误
   - `&&`、`||`、`<`和`>` 操作符能够**正常存在**于`[[ ]]`条件判断结构中，但是如果出现在`[ ]`结构中的话，会报错
      - 可以直接使用`if [[ $a != 1 && $a != 2 ]]`
      - 如果**不适用双括号**, 则为`if [ $a -ne 1] && [ $a != 2 ]`或者`if [ $a -ne 1 -a $a != 2 ]` 
   - `bash`把`双中括号`中的**表达式**看作一个**单独的元素**，并返回一个`退出状态码`    
  
- **例子**
```bash
if ($i<5)    
if [ $i -lt 5 ]    
if [ $a -ne 1 -a $a != 2 ]    
if [ $a -ne 1] && [ $a != 2 ]    
if [[ $a != 1 && $a != 2 ]]    
     
for i in $(seq 0 4);do echo $i;done    
for i in `seq 0 4`;do echo $i;done    
for ((i=0;i<5;i++));do echo $i;done    
for i in {0..4};do echo $i;done    
```

## 大括号、花括号 {}
### 常规用法
1. 大括号拓展
   - (通配(`globbing`))将对`大括号`中的文件名做扩展
      - 在`大括号`中，**不允许有空白**，除非这个空白被引用或转义 
         1. 对`大括号`中的以`逗号`分割的文件列表进行拓展
            -  `touch {a,b}.txt` 结果为`a.txt` `b.txt`
         2. 对`大括号`中以`点点`（`..`）分割的顺序文件列表起拓展作用
            - `touch {a..d}.txt` 结果为`a.txt b.txt c.txt d.txt`   

```bash
# ls {ex1,ex2}.sh    
ex1.sh  ex2.sh    
# ls {ex{1..3},ex4}.sh    
ex1.sh  ex2.sh  ex3.sh  ex4.sh    
# ls {ex[1-3],ex4}.sh    
ex1.sh  ex2.sh  ex3.sh  ex4.sh    
```

2. `代码块`,又被称为`内部组`
   - 这个结构事实上创建了一个`匿名函数`
   - 与`小括号`中的命令**不同**，`大括号`内的命令**不会**新开一个`子shell`运行，
      - 即脚本余下部分仍可使用括号内变量
   - 括号内的命令间用`分号`隔开，**最后一个也必须有`分号`**
   - `{}`的第一个命令和`左括号`之间必须要有一个`空格`

### 几种特殊的替换结构  
`${var:-string},${var:+string},${var:=string},${var:?string}`   

1. `${var:-string}`和`${var:=string}`
   - 若变量`var`为空，则用在命令行中用`string`来替换`${var:-string}`，否则变量`var`不为空时，则用变量`var`的值来替换`${var:-string}`
   - 对于`${var:=string}`的替换规则和`${var:-string}`是一样的，所不同之处是`${var:=string}`若`var`为空时，用`string`替换`${var:=string}`的同时，把`string`赋给变量`var`

   -  `${var:=string}`很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值

2. `${var:+string}`的替换规则和上面的相反
   - 即只有当`var`**不是空**的时候才替换成`string`，若`var`为空时则**不替换**或者说是替换成变量 `var`的值，即`空值`。(因为变量`var`此时为空，所以这两种说法是等价的)  
3. `${var:?string}`替换规则     
   - 若变量`var`不为空，则用变量`var`的值来替换`${var:?string}；`
   - 若变量`var`为空，则把`string`输出到标准错误中，并从脚本中退出。
   - 我们可利用**此特性来检查是否设置了变量的值**

> **Notes**  
> - 在上面这五种替换结构中`string`**不一定**是常值的，可用另外一个变量的值或是一种命令的输出   

### 四种模式匹配替换结构
- 模式匹配记忆方法
    `#` 是去掉左边(在键盘上`#`在`$`之左边)
    `%` 是去掉右边(在键盘上`%`在`$`之右边)
    `#`和`%`中的单一符号是最小匹配，两个相同符号是最大匹配。

- `${var%pattern},${var%%pattern},${var#pattern},${var##pattern}`

    1. `${variable%pattern}`，这种模式时，shell在`variable`中查找，看它是否一给的模式`pattern`**结尾**，如果是，就从命令行把`variable`中的内容去掉*右边*最短的匹配模式
    2. `${variable%%pattern}`，这种模式时，shell在`variable`中查找，看它是否一给的模式`pattern`**结尾**，如果是，就从命令行把`variable`中的内容去掉*右边*最长的匹配模式
    3. `${variable#pattern}` 这种模式时，shell在`variable`中查找，看它是否一给的模式`pattern`**开始**，如果是，就从命令行把`variable`中的内容去掉*左边*最短的匹配模式
    4. `${variable##pattern}` 这种模式时，shell在`variable`中查找，看它是否一给的模式`pattern`**开始**，如果是，就从命令行把`variable`中的内容去掉*右边*最长的匹配模式

> **Notes**  
> - 四种模式中都**不会**改变`variable`的值，
>    - 其中，只有在`pattern`中使用了`*`匹配符号时，`%`和`%%`，`#`和`##`才有区别
> - 结构中的`pattern` 支持通配符，
> - `*`表示零个或多个任意字符，
> - `?`表示零个或一个任意字符，
> - `[...]`表示**匹配**中括号里面的字符，
> - `[!...]`表示**不匹配**中括号里面的字符

- **Demo**
```bash
$ var=testcase    
$ echo $var    
testcase    
$ echo ${var%s*e}   
testca    
$ echo $var    
testcase   
$ echo ${var%%s*e}   
te  
$ echo ${var#?e}    
stcase  
$ echo ${var##?e}    
stcase  
$ echo ${var##*e}    
  
$ echo ${var##*s}    
e    
$ echo ${var##test}    
case    

```

### 字符串提取和替换
- `${var:num},${var:num1:num2},${var/pattern/pattern},${var//pattern/pattern}`
    1. `${var:num}`，这种模式时，shell在`var`中提取第`num`个字符到末尾的所有字符。
        - 若`num`为正数，从左边`0`处开始；
        - 若`num`为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个`num`加上括号，
            - 如`${var: -2}`、`${var:1-3}`或`${var:(-2)}`

    2. `${var:num1:num2}`，`num1`是位置，`num2`是长度。
         - 表示从`$var`字符串的第`$num1`个位置开始提取长度为`$num2`的子串。
            - 不能为负数。
    3. `${var/pattern/pattern}`表示将`var`字符串的**第一个匹配**的`pattern`替换为另一个`pattern`。
             
    4. `${var//pattern/pattern}`表示将`var`字符串中的**所有能匹配**的`pattern`替换为另一个`pattern`。


## 总结
### 符号`$`后的括号
1. `${a}` 变量`a`的值, 
   - 在不引起歧义的情况下*可以省略大括号*。

2. `$(cmd)` 命令替换，和`cmd`效果相同，结果为`shell`命令`cmd`的输，
   - 过某些`Shell`版本**不支持**`$()`形式的命令替换, 如`tcsh`。

3. `$((expression))` 和`exprexpression`效果相同, 计算数学表达式`exp`的数值, 其中`exp`只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。


### 多条命令执行

1. `单小括号`，
   - `(cmd1;cmd2;cmd3)` 新开一个子shell顺序执行命令`cmd1,cmd2,cmd3`,
   -  各命令之间用分号隔开, 最后一个命令后**可以没有分号**。

2. `单大括号`，
   - `{ cmd1;cmd2;cmd3;}` 在当前shell顺序执行命令`cmd1,cmd2,cmd3`, 
   - 各命令之间用分号隔开, 最后一个命令后**必须有分号**,
   - 第一条命令和左括号之间必须用空格隔开。
> **Notes**  
> - 对`{}`和`()`而言, 括号中的重定向符只影响该条命令， 
> - 而括号外的重定向符影响到括号中的所有命令。    


### 双括号的特殊用法
- `(())` 增强括号的用法, 常用于**算术运算比较**. 
   - 双括号中的变量可以**不使用**`$`符号前缀, 只要括号中的表达式符合C语言运算规则, 支持**多个表达式用逗号分开**.
       - 比如可以直接使用`for((i=0;i<5;i++))`, 
       - 如果**不使用双括号**, 则为
       ```bash
       for i in `seq 0 4`
       ```
       - 或者`for i in {0..4}`
       - 再如可以直接使用`if (($i<5))`
       - 如果**不使用**`双括号`, 则为`if [ $i -lt 5 ]`.
- `[[]]` 增强方括号用法, 常用于**字符串的比较**. 
   - 主要用于*条件测试*, 
   - 双括号中的表达式可以使用`&&`,`||`,`<`, `>`等`C语言`语法.
      - 比如可以直接使用`if [[ $a != 1 && $a != 2 ]]`
      - 如果不适用双括号, 则为`if [ $a -ne 1] && [ $a != 2 ]`
      - 或者`if [ $a -ne 1 -a $a != 2 ]`.