# RegExp

## 正则表达式
用来匹配**字符串**的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的

## RegExp
### js创建正则表达式
1. 直接通过`/正则表达式/`写出来
2. 通过`new RegExp('正则表达式')`创建一个`RegExp对象`


```javascript
var re1 = /ABC\-001/;
var re2 = new RegExp('ABC\\-001');

re1; // /ABC\-001/
re2; // /ABC\-001/
```
> 注意：
> 如果使用第二种写法，因为字符串的转义问题，字符串的两`\\`实际上是一个`\`

- 如何判断正则表达式是否匹配?
  - `RegExp对象`的`test()方法`用于测试给定的字符串是否符合条件

## 切分字符串
- 用正则表达式切分字符串比用固定的字符更灵活
```javascript
'a,b;; c  d'.split(/[\s\,\;]+/);  // ['a', 'b', 'c', 'd']
```
## 分组
- 正则表达式还有提取子串的强大功能
  - `()`表示的就是要提取的分组（Group）
- 如果正则表达式中定义了组，就可以在`RegExp对象`上用`exec()`方法提取出子串来  
  - `exec()`方法在匹配成功后，会返回一个`Array`
  - 第一个元素是正则表达式匹配到的整个字符串，
  - 后面的字符串表示匹配成功的**子串**。
  - `exec()`方法在匹配失败时返回`null`


```javascript
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```  

- 贪婪匹配
- 正则匹配默认是**贪婪匹配**
   > 也就是匹配尽可能多的字符

## 全局搜索
- 特殊的标志
  - 最常用的是`g`，表示全局匹配 
  - 指定`i`标志，表示忽略大小写，
  - `m`标志，表示执行多行匹配
  
- 全局匹配类似搜索，因此**不能使用`/^...$/`**，那样只会最多匹配一次 
- 全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串
- 指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引
```javascript
var r1 = /test/g;
// 等价于:
var r2 = new RegExp('test', 'g');
```