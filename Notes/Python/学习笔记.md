# Python学习笔记


## Python简介
- Python是一种非常高级的语言
- Python学了可以做什么？不可以做什么？
   - 可以做：日常任务 网站  游戏后台
   - 不能做 ：`操作系统` 、`手机应用`、`3D游戏`
- 内置电池**batteries included**
   - Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。
- Python的特点
  - **优雅**、**明确**、**简单**

- Python适合开发哪些类型的应用呢？
  1. 网络应用，包括网站、后台服务等等
  2. 许多日常需要的小工具，包括系统管理员需要的脚本任务
  3. 把其他语言开发的程序再包装起来，方便使用---*胶水语言*

- Python缺点
  1. 运行速度相对较慢  
  > Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢
  2. 代码不能加密
  > 凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去

## Python的集成环境
- Python是跨平台的
- Python的版本
  - Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的
- Python的安装

- Python交互式环境
  - `>>>`

## Python解释器
- 运行Python代码  
  编写Python代码时，我们得到的是一个包含Python代码的以`.py`为扩展名的文本文件，**运行代码，就需要Python解释器去执行.py文件**

- 多种Python解释器

### CPython
- 官方版本的解释器：CPython
- 解释器是用C语言开发的
- 命令行下运行python就是启动CPython解释器
- 交互式环境
   - `>>>`
### IPython
> IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的
- CPython用`>>>`作为提示符，而IPython用`In [序号]`:作为提示符。

### PyPy
- PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以**显著提高Python代码的执行速度**

### Jython

### IronPython

>Python的解释器很多，但使用最广泛的还是**CPython**。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性

## Python的开发IDE
- Sublime Text
- Notepad++
- Pycharm
- VS Core

## 入门必知
- 必须要以`.py`结尾，其他的都不行。
- 文件名只能是英文字母、数字和下划线的组合
- 直接运行py文件
   - 在Windows上是**不行**的，但是，在Mac和Linux上是可以的

``` 
#!/usr/bin/env python

```  
然后，通过命令：

```  

$ chmod a+x hello.py
```

- Python的交互模式和直接运行.py文件有什么区别呢？

   - 直接输入python进入交互模式，相当于启动了Python解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。

   - 直接运行.py文件相当于启动了Python解释器，然后一次性把.py文件的源代码给执行了，你是没有机会输入源代码的。


## 输入和输出
-  输出
   - `print`
     > print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：
- 输入
  - `raw_input`
  - `raw_input()`读取的内容永远以字符串的形式返回，把字符串和整数比较就不会得到期待的结果，必须先用int()把字符串转换为我们想要的整型：

  ```python
  >>> name = raw_input()
     Michael
  ```
- 标准输入输出`stdio`
  - `标准输入文件（stdin）` -- 通常对应终端的键盘；
  -  标准输出文件（stdout）
  - 标准错误输出文件（stderr）

> 输入是`Input`，输出是`Output`，因此，我们把输入输出统称为`Input/Output`，或者简写为`IO`

## Python语法基础
> 任何一种编程语言都有自己的一套语法，编译器或者解释器就是负责把符合语法的程序代码转换成CPU能够执行的机器码

- Python的语法比较简单，采用**缩进方式**
- Python的注释  
  `#这个是注释，解释器会忽略掉注释`
- 代码块
   - 语句**以冒号:结尾时，缩进的语句**视为代码块 
   - 按照约定俗成的管理，应该始终坚持*使用4个空格的缩进*
- Python程序是大小写敏感的，如果写错了大小写，程序会报错


> 日期：2016-08-23

## Python数据类型
- 整数
  - 十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示
- 浮点数
- 字符串
  - 字符串是以`''`或`""`括起来的任意文本，比如`'abc'`，`"xyz"`等等
  - `''`或`""`本身只是一种表示方式，不是字符串的一部分
  - 转义字符`\`
    1. \n表示换行，
    2. \t表示制表符，
    3. 字符\本身也要转义，所以\\表示的字符就是\
  - 多行字符串`'''...'''`还可以在前面加上r使用
- 布尔值
  - `True`
  - `False`
  - 布尔值可以用`and`、`or`和`not`运算
- 空值
   - `None`
   - `None`是一个特殊的空值

- 变量
  - 变量名必须是大小写英文、数字和_的组合，且不能用数字开头
  - 等号`=`是**赋值语句**，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且**可以是不同类型的变量**
  - 对变量赋值就是把数据和变量给关联起来。

- 常量
  - 常量就是**不能变的变量**
  - 在Python中，通常用**全部大写的变量名**表示常量

## 字符串和编码
- 字符编码
  - 8个比特（bit）作为一个字节（byte）
  - `ASCII`编码
  - Unicode
  - UTF-8
- Python的字符串
  - Python提供了`ord()`和`chr()`函数，可以把字母和对应的数字相互转换
  - Python在后来添加了对Unicode的支持，以Unicode表示的字符串用`u'...'`表示
  - 把`u'xxx'`转换为UTF-8编码的'xxx'用`encode('utf-8')`方法：
  - 把UTF-8编码表示的字符串'xxx'转换为Unicode字符串u'xxx'用`decode('utf-8')`方法
  - Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码
  ```
  #!/usr/bin/env python
  # -*- coding: utf-8 -*-
  ```
  - `len()`函数可以返回字符串的长度：

 - 格式化
   - Python中，采用的格式化方式和C语言是一致的，用`%`实现
   ```python
   >>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
   'Hi, Michael, you have $1000000.'
   ``` 
   - `%运算符`就是用来格式化字符串的
   - 占位符
     1. %d	整数
     2. %f	浮点数
     3. %s	字符串
     4. %x	十六进制整数

  - 格式化整数和浮点数还可以指定是否补0和整数与小数的位数
   ```python
   >>> '%2d-%02d' % (3, 1)
' 3-01'
   >>> '%.2f' % 3.1415926
'3.14'
   ```
   - 不太确定应该用什么，`%s`**永远起作用**，它会把任何数据类型转换为字符串
   - 用`%%`来表示一个`%`

> Python当然也支持其他编码方式，比如把Unicode编码成GB2312：
但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用Unicode和UTF-8这两种编码方式。
## 动态语言/静态语言
- 变量本身类型不固定的语言

## 使用list和tuple
- list
   - `[]`
   - `list`是一种**有序的集合**，可以随时添加和删除其中的元素
   - `len()`函数可以获得list元素的个数
   - `索引`来访问list中每一个位置的元素，记得索引是从0开始,最后一个元素的索引是`len(classmates) - 1`
      1. `classmates.append('Adam')`
      2.把元素插入到指定的位置，比如索引号为1,`classmates.insert(1, 'Jack')`
      3. 删除list末尾的元素,用`pop()`方法
      4.删除指定位置的元素，用`pop(i)`方法
      5.list里面的元素的数据类型也可以不同
      6.list元素也可以是另一个list
      7. 空的list，它的长度为0  `L = []`
- tuple
  - 有序列表,一旦初始化就不能修改
  - 它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，**但不能赋值成另外的元素**
  - 定义一个空的tuple，可以写成`t=()`
  - 定义一个只有1个元素的tuple
     1. `()`既可以表示tuple，又可以表示数学公式中的小括号
     2. 只有1个元素的tuple定义时必须加一个逗号, `t = (1,)`
     3. *可变的*`tuple`==> t = ('a', 'b', ['A', 'B'])

## 条件判断和循环
- 条件判断
  - `if`语句:
  - `if...else`
  - `elif`
  - 只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False
  ```python
  if x:
    print 'True'
  ```
- 循环（循环有两种）
  1. `for x in ...循环`
     - 把list或tuple中的每个元素迭代出来
     - `range()函数`:生成一个整数序列
  2. 循环是`while循环`

## 使用dict和set
### dict（字典）==>`d={'key':'value'}`
- dict全称dictionary，在其他语言中也称为map，使用**键-值（key-value）**存储，**具有极快的查找速度**
- 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉
- **读取**字典的值时，key不存在，dict就会报错
- 要避免key不存在的错误
   1. 一是通过in判断key是否存在
   2. dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value
   ```python
   >>> d.get('Thomas')
   >>> d.get('Thomas', -1)
   ```
- 要删除一个key，用`pop(key)`方法，对应的value也会从dict中删除：
- 和list比较，dict有以下几个特点：
  1. 查找和插入的速度极快，不会随着key的增加而增加
  2. 需要占用大量的内存，内存浪费多
- `list`的特点
  1. 查找和插入的时间随着元素的增加而增加；
  2. 占用空间小，浪费内存很少。
> dict是用空间来换取时间的一种方法


- 需要牢记的第一条就是dict的**key必须是不可变对象**。  
- 哈希算法（Hash）
- 在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：
  
### set
- **一组key的集合，但不存储value。**由于key不能重复，所以，在set中，没有重复的key。
- 重复元素在set中自动被过滤
- `s = set([1, 1, 2, 2, 3, 3])`
- `add(key)`方法可以添加元素到set中，可以重复添加，但不会有效果
- `remove(key)`方法可以删除元素
- set可以看成数学意义上的**无序**和**无重复元素**的集合，因此，两个set可以做数学意义上的交集、并集等操作
```python
>>> s1 = set([1, 2, 3])
>>> s2 = set([2, 3, 4])
>>> s1 & s2
set([2, 3])
>>> s1 | s2
set([1, 2, 3, 4])
```

- set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样


## 不可变对象
- str是不变对象，而list是可变对象
- 可变对象，比如list，对list进行操作，list内部的内容是会变化的
>a.replace('a', 'A')时，实际上调用方法replace是作用在字符串对象'abc'上的，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法创建了一个新字符串'Abc'并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了
-对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，**这些方法会创建新的对象并返回**，这样，就保证了不可变对象本身永远是不可变的

>日期：2016-08-24



## 函数
- 所有的高级语言都支持函数
- 函数就是*最基本的一种代码抽象的方式*
- 调用函数
   - 需要知道函数的**名称**和**参数**
   - **函数名**其实就是指向一个函数对象的引用，
   完全可以把函数名赋给一个变量， 相当于给这个函数起了一个“别名”
   ```python
   >>> a = abs # 变量a指向abs函数
   >>> a(-1) # 所以也可以通过a调用abs函数
   ```
   - 如果函数调用出错，一定**要学会看错误信息**，所以英文很重要！

  
### Python内置的常用函数

### 数据类型转换
- `int()`函数可以把其他数据类型转换为整数
- `float()`
- `str()`
- `unicode()`
- `boo()`

### 定义函数
- 定义一个函数要使用`def语句`，依次写出`函数名`、`括号`、括号中的`参数`和`冒号:`
```python
def my_abs(x):
    if x >= 0:
        return x
    else:
        return -x
```

- 一旦执行到`return`时，函数就执行完毕，并将结果返回
- 函数内部的复杂逻辑被封装起来，调用者无需了解

### 空函数
- 定义一个什么事也不做的空函数，可以用pass语句
```python
def nop():
    pass
```
- `pass语句`:什么都不做，占位符的作用

### 参数检查
- 参数个数不对，Python解释器会自动检查出来，并抛出`TypeError`
- 数据类型检查可以用内置函数`isinstance`实现

### 返回多个值
- Python的函数返回多值其实就是返回一个`tuple`，但写起来更方便

>- 定义函数时，需要确定函数名和参数个数；
>- 如果有必要，可以先对参数的数据类型做检查；
>- 函数体内部可以用`return`随时返回函数结果；
>- 函数执行完毕也没有return语句时，自动`return None`。
>-函数可以同时返回多个值，但其实就是一个`tuple`。

### 函数的参数
- 默认参数
```python
def power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s * x
    return s
```
  - 默认参数可以简化函数的调用
     1. 必选参数在前，默认参数在后，否则Python的解释器会报错
     2. 函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数
     3. 默认参数有什么好处？最大的好处是能降低调用函数的难度

  - 默认参数很有用，但使用不当，也会掉坑里
    1. 定义默认参数要牢记一点：默认参数**必须指向不变对象！**
- 可变参数
  > **可变参数**允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个`tuple`
```python
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
```
  - Python允许你在`list`或`tuple`前面加一个`*号`，把`list`或`tuple`的元素变成可变参数传进去
  ```python
  >>> nums = [1, 2, 3]
  >>> calc(*nums)
  14
  ```
- 关键字参数
  >**关键字参数**允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个`dict`

  - 关键字参数有什么用？
  > 它可以扩展函数的功能,除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。

- 参数组合
> 可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中某些，但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。

```python
def func(a, b, c=0, *args, **kw):
    print 'a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw
```
   
   - 对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的
 > 1. `*args`是可变参数，args接收的是一个tuple；
 > 2. `**kw`是关键字参数，kw接收的是一个dict。
 > 3. `*args`和`**kw`是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法

### 递归函数
> 如果一个函数**在内部调用自身本身**
```python
def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
```
  - **优点：**定义简单，逻辑清晰
  > 理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰
  - 使用递归函数需要注意**防止栈溢出**
  > 解决递归调用栈溢出的方法是通过**尾递归优化**
  - 任何递归函数都存在栈溢出的问题

  - **尾递归**
  > 在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

```python
def fact(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
```


### 抽象
- 借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题
- 一行代码能实现的功能，决不写5行代码


>日期：2016-08-24


## 高级特性

### 切片
- 取一个`list`或`tuple`的部分元素是非常常见的操作==>使用切片**切片**
- `L[开始索引:结束索引:间隔个数]`
  - 第一个索引是0，还可以省略
  - 间隔个数默认为`1`，可以省略
- 只写`[:]`就可以原样复制一个`list`
- 字符串切片
  - Python没有针对字符串的截取函数，只需要切片一个操作就可以完成

>很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片

### 迭代
> `迭代（Iteration）`:对可迭代对象的遍历，使用 `for...in...`
- 可迭代对象:
   - 如何判断一个对象是可迭代对象呢？方法是通过`collections`模块的`Iterable`类型判断：
   ```python
   >>> from collections import Iterable
   >>> isinstance('abc', Iterable) # str是否可迭代
   True
   >>> isinstance([1,2,3], Iterable) # list是否可迭代
   True
   >>> isinstance(123, Iterable) # 整数是否可迭代
   False
   ```
- dict的迭代
  - 默认情况下，`dict`迭代的是`key`
  - 迭代`value`，可以用`for value in d.itervalues()`
  - 如果要**同时迭代key和value**，可以用`for k, v in d.iteritems()`

- 对`list`实现类似Java那样的下标循环怎么办?
  - Python内置的`enumerate`函数可以把一个list变成索引-元素对
```python
>>> for i, value in enumerate(['A', 'B', 'C']):
...     print i, value
...
0 A
1 B
2 C
```
> 任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环


### 列表生成式
> **列表生成式**即`List Comprehensions`，是Python内置的非常简单却强大的可以用来创建list的生成式
-  `[generateItem for item in list if条件]`
    - `[要生成的元素表达式 for循环 if条件]`

- 作用： 
   - 快速生成`list`
   - 可以通过一个list推导出另一个list

## 生成器（Generator）
- 创建一个`generator`
   1. 只要把一个列表生成式的[]改成`()`
   ```python
   >>> L = [x * x for x in range(10)]
   >>> L
   [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
   >>> g = (x * x for x in range(10))
   >>> g
   <generator object <genexpr> at 0x104feab40>
   ```
   2. 使用函数的方式创建一个`generator`
   > 一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个`generator`
   ```python
   def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
   ```

- 我们怎么打印出`generator`的每一个元素呢？
   - `g.next()`
   - 没有更多的元素时，抛出`StopIteration`的错误

- `generator`也是可迭代对象 
  - 一般地，正确获取生成器对象的元素应当使用使用`for循环`

>`generator`的函数，在每次调用`next()`的时候执行，遇到`yield`语句返回，再次执行时从上次返回的`yield`语句处继续执行

> 我们创建了一个`generator`后，基本上永远不会调用`next()`方法，而是通过`for循环`来迭代它
> 可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator

>日期：2016-08-24


## 函数式编程
 - 函数就是面向过程的程序设计的基本单元
> 函数式编程（请注意多了一个“式”字）——`Functional Programming`
>  - 一种抽象程度很高的编程范式
>  - 纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用

- `函数式编程`的一个特点就是，**允许把函数本身作为参数传入另一个函数，还允许返回一个函数！**
- Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。

### 高阶函数----Higher-order function
> 函数作为参数
> 函数作为返回值

- 函数本身也可以赋值给变量，即：**变量可以指向函数**
```python
>>> f = abs
>>> f
<built-in function abs>
```
- 函数名也是变量
  - 函数名其实就是指向函数的变量
- 传入函数
  > 高阶函数 : 一个函数就可以接收另一个函数作为参数
  > 目的： 就是让函数的参数能够接收别的函数

```python
def add(x, y, f):
    return f(x) + f(y)
```
#### map/reduce

- `map()`函数接收两个参数，一个是函数，一个是序列,`map`将传入的函数依次作用到序列的每个元素，并把结果作为`新的list`返回
- `reduce()`
  - reduce把一个函数作用在一个序列[x1, x2, x3...]上，这个函数**必须接收两个参数**，reduce把结果继续和序列的下一个元素做累积计算
  ```python
  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
  ```

#### filter
- `filter()函数`: 过滤序列
  - `filter()`把传入的函数依次作用于每个元素，然后根据返回值是`True`还是`False`决定保留还是丢弃该元素

#### sorted
- `sorted()`函数就可以对list进行排序,也是一个高阶函数，`sorted([],sorted_func)`

 
 ### 函数作为返回值

```python
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
```

### 闭包
> **返回的函数**在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其**内部的局部变量还被新函数引用**

### 匿名函数----lambda 
- 匿名函数有个限制，就是**只能有一个表达式**，不用写return，返回值就是该表达式的结果
- lambda作为参数
- lambda作为返回值

```python
lambda x: x * x
```
> Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数

### 装饰器----Decorator
> 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）

1. 存在函数`now()`
```python
>>> def now():
...     print '2013-12-25'
...
>>> f = now
>>> f()
2013-12-25
```
> 函数对象有一个__name__属性，可以拿到函数的名字：

2. 我们**要增强now()函数的功能**，比如，在函数调用前后自动打印日志，但**又不希望修改now()函数的定义**
> 本质上：`decorator`就是一个**返回函数的高阶函数**
```python
def log(func):
    def wrapper(*args, **kw):
        print 'call %s():' % func.__name__
        return func(*args, **kw)
    return wrapper
```
   - `log`函数就是一个装饰器---> **接受一个函数作为参数，并返回一个函数**
 3. 装饰器的使用
 ```python
 @log
def now():
    print '2013-12-25'
 ```  
   - 把@log放到now()函数的定义处，相当于执行了语句：`now = log(now)`
   > 1. 由于`log()`是一个`decorator`，**返回一个函数**，所以，**原来的`now()`函数仍然存在，只是现在同名的now变量指向了新的函数**，于是调用`now()`将执行新函数，即在`log()`函数中返回的`wrapper()`函数。
   > 2. `wrapper()`函数的参数定义是`(*args, **kw)`，因此，`wrapper()`函数可以接受任意参数的调用。在wrapper()函数内，**首先打印日志**，**再紧接着调用原始函数。**

4. `decorator`本身需要传入参数，那就需要编写一个**返回decorator的高阶函数**，写出来会更复杂
```python
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print '%s %s():' % (text, func.__name__)
            return func(*args, **kw)
        return wrapper
    return decorator
```
   - 两层嵌套的`decorator`相比，3层嵌套的效果是这样的: `now = log('execute')(now)`
   - 首先执行log('execute')，返回的是`decorator`函数，再调用返回的函数，参数是`now`函数，返回值最终是`wrapper`函数 

5. 函数也是对象，它有`__name__`等属性，但你去看经过`decorator`装饰之后的函数，**它们的`__name__`已经从原来的`'now'`变成了`'wrapper'`**
  
  -不带参数的装饰器
```python
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print 'call %s():' % func.__name__
        return func(*args, **kw)
    return wrapper
```
   - 带参数的装饰器
  
   ```python
   import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print '%s %s():' % (text, func.__name__)
            return func(*args, **kw)
        return wrapper
    return decorator
   ```

> - Python的`decorator`可以**用函数实现**，也可以用**类实现**  
> - 装饰器的本质就是现有的对象(函数)的行为/功能增强的一种方式方法  
> - python的装饰器有：
>    1. 不带参数的装饰器，两层嵌套--->返回一个**普通函数**
>    2. 带参数的装饰器，三层嵌套--->返回一个**高阶函数**  
> 
> python装饰器名称的改变 
> - 在定义`wrapper()`的前面加上`@functools.wraps(func)`即可
 
## 偏函数 --- Partial function
-  functools模块
> `functools.partial`的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单
```python
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
```
> 使用`functools.partial`可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单 


### 模块
- 在Python中，一个`.py文件`就称之为一个模块`Module`
- 使用模块有什么好处？
   - 大大提高了代码的可维护性
   - 编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用
   - 可以避免函数名和变量名冲突
      > 尽量不要与内置函数名字冲突
#### 使用模块
- 在命令行运行hello模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，
- 而如果在其他地方导入该hello模块时，if判断将失败
> 使用命令行执行一个模块时，他的`__name__`属性为`__main__`  
> 使用`import`语句导入模块后，模块的`__name__`名称为模块的文件名

#### 别名
- 使用 `as` 关键字
```python
try:
    import cStringIO as StringIO
except ImportError: # 导入失败会捕获到ImportError
    import StringIO
```

#### 作用域
- `__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途,我们自己的变量一般不要用这种变量名
- `_xxx`和`__xxx`这样的函数或变量就是非公开的（`private`），**不应该被直接引用**，比如_abc，__abc
  > `private函数`和`变量`**不应该**被直接引用，而**不是不能**被直接引用
- 正常的函数和变量名是公开的`public`

> 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public

#### 安装第三方模块
- 安装第三方模块，是通过`setuptools`这个工具完成的
- Python有两个封装了`setuptools`的包管理工具：
  - `easy_install`
  - `pip`  ---->官方推荐
- **模块搜索路径**
   - Python解释器会搜索
      1. 当前目录、
      2. 所有已安装的内置模块
      3. 第三方模块，
   - 搜索路径存放在`sys模块`的`path变量`
- 如何添加自己的搜索目录？
   1. 直接修改`sys.path`
   ```python
   >>> import sys
   >>> sys.path.append('/Users/michael/my_py_scripts')
   ```
   > 在**运行时修改，运行结束后失效**
   2. 设置环境变量`PYTHONPATH`
   
### 包---Package
- 包目录下面都会有一个`__init__.py`的文件，这个文件是**必须**存在的，否则，Python就把这个目录当成普通目录，而不是一个包。
  >  __init__.py可以是空文件，也可以有Python代码



> 日期：2016-08-27 

## 使用__future__
> Python的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。有些改动是不兼容旧版本的，也就是在当前版本运行正常的代码，到下一个版本运行就可能不正常了
- Python为了确保你能顺利过渡到新版本，特别提供了__future__模块，让你在旧的版本中试验新版本的一些特性


## 面向对象编程---- Object Oriented Programming，简称OOP
- `OOP`把`对象[object]`作为程序的基本单元，一个对象包含了`数据`和`操作`数据的函数
> 必须牢记**类是抽象的模板**，比如Student类，而实例是根据类创建出来的一个个具体的`对象`，每个`对象`都拥有相同的方法，但各自的数据可能不同

### 面向对象和面向过程的区别
- 面向过程的程序设计
  - 把计算机程序视为一系列的命令集合，即一组函数的顺序执行
  > 为了简化程序设计：把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度

- 面向对象的程序设计
  - 把计算机程序视为一组对象的集合，
  > 而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递

- 面向对象的设计思想是从自然界中来的
  > 自然界中，类（`Class`）和实例（`Instance`）的概念是很自然的
  - `Class`是一种抽象概念
  - 实例（`Instance`）则是一个个具体的对象
  > 面向对象的设计思想是抽象出`Class`，根据`Class`创建`Instance`

 - 面向对象的三大特征
   - 封装
   - 继承
   - 多态

### Python中的面向对象
- 所有数据类型都可以视为对象
- 自定义对象[`Class`]

### 类和实例
- 定义类：通过`class`关键字

```python
class Student(object):
    pass
```
- 根据`Student`类创建出`Student`的实例： `类名()`
```python
>>> bart = Student()
>>> bart
<__main__.Student object at 0x10a67a590>
>>> Student
<class '__main__.Student'>
```
>变量`bart`指向的就是一个`Student`的`object`，后面的`0x10a67a590`是内存地址，**每个object的地址都不一样**，而`Student`本身则是一个类。

#### __init__方法
- 构造方法
   - `__init__`方法的第一个参数永远是`self`，表示创建的实例本身
   > `__init__`方法，在创建实例的时候，就不能传入空的参数了，
   > 必须传入与`__init__`方法匹配的参数，但`self`不需要传，Python解释器自己会把实例变量传进去

#### 数据封装
- `方法`和`函数`的区别
  - 方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据

#### 访问限制


> 日期：2016-08-27